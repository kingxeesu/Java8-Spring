**CHAPTER 2**

**스프링 부트 공통 작업**

### 애플리케이션 설정 관리

**설정 정보의 중요성**

- 모든 애플리케이션에서 중요한 요소
- 개발(dev), 테스트(test), 스테이징(staging), 상용(prod) 등 환경에 따라 설정 정보 달라짐

**설정 정보 관리의 어려움**

- 배포 환경에 따라 설정 정보 변경 필요
- 애플리케이션 소스 코드는 거의 동일
- 설정 정보 증가에 따른 관리 어려움

**스프링 부트의 설정 정보 관리**

- 프로퍼티 파일, YAML 파일, 환경 변수, 명령행 인자 등 다양한 방법 제공
- 소스 코드 변경 없이 환경마다 설정 정보 적용 가능

---

### SpringApplication 클래스 사용

- SpringApplication 클래스로 설정 정보 정의
    - `setDefaultProperties()` 메서드 사용
    - `java.util.Properties` 또는 `java.util.Map<String, Object>` 타입 인자
    - 소스 코드에 설정 정보 직접 정의
    - 변경 빈도가 낮은 설정 정보에 적합
- application.properties 파일에서 설정 정보 임포트
    - `spring.config.import` 프로퍼티 사용
    - 다른 properties 또는 .yml 파일 임포트
    - ex) `spring.config.import=classpath:additional-application.properties`
- 설정 파일 존재하지 않을 때 예외 처리
    - 기본적으로 `ConfigDataLocationNotFoundException` 예외 발생
    - `spring.config.on-not-found` 프로퍼티 사용
    - `ignore` 값 설정 시 예외 무시하고 애플리케이션 실행 계속 진행


```java
package com.manning.sbip.ch02;

import java.util.Properties;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootAppDemoApplication {

	public static void main(String[] args) {
		
		Properties properties = new Properties();
		properties.setProperty("spring.config.on-not-found", "ignore");
		
		SpringApplication application = new SpringApplication(SpringBootAppDemoApplication.class);
		application.setDefaultProperties(properties);
		application.run(args);
	}
}
```

예제 설명

- `SpringApplication` 클래스 인스턴스 생성
- `spring.config.on-not-found` 속성을 "ignore"로 설정한 `Properties` 객체 생성
- `setDefaultProperties()` 메서드에 `Properties` 객체 전달
- `run()` 메서드 호출하여 애플리케이션 실행

---

### @PropertySource 사용

- 프로퍼티 파일 위치 지정
    - `@PropertySource` 애너테이션 사용
    - 예시: `@PropertySource("classpath:dbConfig.properties")`
- 설정 정보 읽어오기:
    - `@Autowired`를 사용하여 `Environment` 인스턴스 주입
    - `env.getProperty("key")` 메서드 사용하여 설정 정보 접근
- 예제


    ```java
    	@Configuration
    @PropertySource("classpath:dbConfig.properties")
    public class DbConfiguration {
    
      @Autowired
      private Environment env;
    
      @Override
      public String toString() {
        return "User: " + env.getProperty("user") + ", Password: " + env.getProperty("password");
      }
    }
    ```
    
    DbConfiguration 클래스
    
    - `@Configuration` 애너테이션 : 스프링 환경 설정 클래스임을 나타냄
    - `@PropertySource` 애너테이션 : `dbConfig.properties` 파일의 위치를 지정
    - `Environment` 인스턴스 주입 : `@Autowired` 애너테이션을 사용하여 `Environment` 인스턴스를 주입받음
    - `toString()` 메서드 : 설정 정보를 출력
    
    ```java
    @SpringBootApplication
    public class SpringBootAppDemoApplication {
    
      private static final Logger log = LoggerFactory.getLogger(SpringBootAppDemoApplication.class);
    
      public static void main(String[] args) {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(SpringBootAppDemoApplication.class, args);
        DbConfiguration dbConfiguration = applicationContext.getBean(DbConfiguration.class);
        log.info(dbConfiguration.toString());
      }
    }
    ```
    
    SpringBootAppDemoApplication 클래스
    
    - `@SpringBootApplication` 애너테이션: 스프링 부트 애플리케이션임을 나타
    - `main()` 메서드: `DbConfiguration` 빈을 생성하고 `toString()` 메서드를 호출하여 설정 정보를 출력
    
    ```java
    user=sa
    password=p@ssw0rd
    ```
    
    dbConfig.properties 파일
    
    - `user` 키 : 데이터베이스 사용자 이름을 설정
    - `password` 키 : 데이터베이스 비밀번호를 설정
    
    ---
    
    실행 결과
    
    - 콘솔에 User, password 값이 출력됨
    
    ![스크린샷 2024-04-06 오후 4.48.19.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/dce14b79-3d6e-4eb9-9fa9-4a7d26948c3e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.48.19.png)

- @PropertySource 애너테이션으로 YML 또는 YAML 파일을 지정해서 사용할 수는 없음. YML 파일을 사용 하려면 추가 작업이 필요
- 자바 8 이후로는 동일한 애너테이션을 여러 번 사용할 수 있으므로, 여러 프로퍼티 파일을 각각 @Property-Source로 지정해서 사용할 수 있음

```java
@Configuration
@PropertySource("classpath:dbConfig-properties")
@PropertySource("classpath:redisConfig properties")
public class DbConfiguration {
//
}
```

---

환경 설정 파일

- **프로퍼티 파일 vs YML 파일**
    - 스프링 부트는 `application.properties` 또는 `application.yml` 파일을 사용하여 환경 설정 정보를 관리함
        - 두 파일 모두 동일한 기능을 제공하지만 YML 파일은 더 간결하고 읽기 쉬운 형식
            - ex)
                - application.properties

                  Properties

                    ```java
                    server.port=8081
                    spring.datasource.username=sa
                    spring.datasource.password=password
                    ```

                - application.yml

                  YAML

                    ```java
                    server:
                      port: 8081
                    spring:
                      datasource:
                        username: sa
                        password: password
                    ```

- **설정 파일 이름 변경**
    - application.properties 또는 application.yml 파일의 이름을 변경하려면 `spring.config.name` 프로퍼티를 사용
        - ex)
            - sbip.yml 파일 생성
            - `java -jar target/config-data-file-0.0.1-SNAPSHOT.jar --spring.config.name=sbip` 실행
- **설정 파일 위치**
    - 스프링 부트는 기본적으로 다음 위치에 있는 설정 파일을 읽음
        - 클래스패스 루트
            - 클래스패스 `/config` 패키지
            - 현재 디렉터리
            - 현재 디렉터리 `/config` 디렉터리
            - `/config` 디렉터리의 바로 하위 디렉터리
        - `spring.config.location` 프로퍼티를 사용하여 다른 위치에 있는 설정 파일을 읽을 수 있음
        - ex)
            - data 디렉터리에 sbip.yml 파일 생성
            - `java -jar target/config-data-file-0.0.1-SNAPSHOT.jar --spring.config.location=data/sbip.yml` 실행
- **설정 파일 선택**
    - 스프링 부트는 여러 설정 파일을 사용하여 환경별 설정을 분리할 수 있음
        - ex)
            - application-dev.properties: server.port=9090
            - application-test.properties: server.port=9091
        - `spring.profiles.active` 프로퍼티를 사용하여 활성화할 프로파일을 지정
        - ex)
            - `java -jar target/config-data-file-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev` 실행
- **설정 파일 로딩 순서**
    - 설정 파일은 다음 순서로 로딩
        1. 애플리케이션 JAR 파일 안에 패키징되는 `application.properties`(또는 yml) 파일
            1. 애플리케이션 JAR 파일 안에 패키징되는 `application-(profiles).properties`(또는 yml) 파일
            2. 애플리케이션 JAR 파일 밖에서 패키징되는 `application.properties`(또는 yml) 파일
            3. 애플리케이션 JAR 파일 밖에서 패키징되는 `application-(profiles).properties`(또는 yml) 파일

### 예제 코드

- 설정 파일 이름 변경

```java
public class SpringBootAppDemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(SpringBootAppDemoApplication.class, args);
  }
}
```

```java
# sbip.yml
server:
  port: 8081
java -jar target/config-data-file-0.0.1-SNAPSHOT.jar --spring.config.name=sbip
```

- **설정 파일 위치**

```java
public class SpringBootAppDemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(SpringBootAppDemoApplication.class, args);
  }
}
```

```java
# data/sbip.yml
server:
  port: 8081
java -jar target/config-data-file-0.0.1-SNAPSHOT.jar --spring.config.location=data/sbip.yml
```

<aside>
💡 **spring.config.name과 spring.config.properties**

- 스프링 부트는 애플리케이션 스타트업 과정 중 매우 이른 단계에서 spring.config.name과 spring.con-fig.location 값을 로딩함.
- 그래서 이 두 프로퍼티를 application.properties 파일이나 application.yml 파일에서 지정할 수 없음.
- 이 두 프로퍼티는 SpringApplication.setDefaultProperties() 메서드나 OS 환경 변수, 명령행 인자로 지정해야만 정상적으로 동작.
- 예제에서는 명령행 인자로 지정
</aside>

<aside>
💡 명령행 인자

- 스프링 부트 애플리케이션을 JAR 파일로 만든 후에 애플리케이션 실행 시 명령행 인자로 설정 정보를 지정할 수도 있음.
- 앞의 예제에서 spring.config.name이나 spring.config.location 프로퍼티를 명령행 인자로 지정해서 사용
</aside>

- **운영 체제 환경 변수**
    - **환경 변수 사용**
        - 운영 체제 환경 변수로 지정한 값을 설정 정보 파일에서 읽어서 사용할 수 있음
        - ex)
            - application.properties

                ```java
                Properties
                app.timeout=${APP_TIMEOUT}
                ```

            - 윈도우 : set APP_TIMEOUT=30
            - 리눅스 : export APP_TIMEOUT=30
            - java -jar target/config-data-file-0.0.1-SNAPSHOT.jar 실행

  —> 결론

    - 명령행 인자 > 운영 체제 환경 변수 > `@PropertySource` > 설정 정보 파일

  ex)

    ```java
    @SpringBootApplication
    public class SpringBootAppDemoApplication {
    
      private static final Logger log = LoggerFactory.getLogger(SpringBootAppDemoApplication.class);
    
      public static void main(String[] args) {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(SpringBootAppDemoApplication.class, args);
        Environment env = applicationContext.getBean(Environment.class);
        log.info("Configured application timeout value: " + env.getProperty("app.timeout"));
      }
    }
    ```


---

### @ConfigurationProperties로 커스텀 프로퍼티 만들기

- **프로퍼티 접근:** 프로퍼티에 대한 getter/setter 메서드를 자동으로 생성
- **데이터 유효성 검사:** `@NotNull` 과 같은 JSR-303 애너테이션을 사용하여 데이터 유효성 검사를 수행할 수 있음
- **환경 변수 바인딩:** 프로퍼티 이름을 환경 변수 이름과 동일하게 설정하면 자동으로 바인딩됨

**기법 : @ConfigurationProperties를 사용한 커스텀 프로퍼티 정의**

- 요구 사항
    - 커스텀 프로퍼티에 대해 타입 안전성을 보장하고 값의 유효성을 검증해야 함
- 해법
    - @Configuration 애너테이션을 사용해 프로퍼티 정보를 담는 클래스를 만들어서 타입 안전성을 보장하고 유효성을 검증.
    - 이렇게 하면 0Value 애너테이션이나 Environment 객체를 사용하지 않고도 프로퍼티값을 읽어서 사용할 수 있음.

```java
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-configuration-processor</artifactId>
	<optional>true</optional>
</dependency>
```

**@ConfigurationProperties 애너테이션 사용 시 메타데이터 생성**

- `@ConfigurationProperties` 애너테이션이 붙어 있는 클래스에 대한 메타데이터는 스프링 부트 설정 처리기(configuration processor)가 생성함
- 이 메타데이터는 IDE에서 다음과 같은 기능을 지원하는 데 사용됨
    - application.properties(또는 yml) 파일에 기술된 프로퍼티에 대한 자동 완성
    - 프로퍼티에 대한 문서화

- 스프링 부트 설정 처리기는 `spring-boot-configuration-processor`라는 Maven 의존성으로 제공됨
- IDE에서 자동 완성 및 문서화 기능을 사용하려면 이 의존성을 프로젝트에 추가 필요
- **메타데이터 생성 과정**
    1. 스프링 부트 설정 처리기는 `@ConfigurationProperties` 애너테이션이 붙어 있는 클래스를 검색
    2. 클래스의 프로퍼티 정보를 분석
    3. 프로퍼티 정보를 기반으로 메타데이터를 생성
    4. IDE는 메타데이터를 사용하여 자동 완성 및 문서화 기능을 제공
- **@ConfigurationProperties 애너테이션 사용법**
    - `prefix` 속성: 프로퍼티 이름의 접두사를 지정
    - `ignoreUnknownFields` 속성: 설정 파일에 정의되지 않은 프로퍼티를 무시할지 여부를 지정
    - `ignoreInvalidFields` 속성: 유효하지 않은 값을 가진 프로퍼티를 무시할지 여부를 지정

**AppProperties 클래스**

- `AppProperties` 클래스는 스프링 부트 설정 정보를 담는 커스텀 프로퍼티 클래스
- 주요 특징
    - `@ConstructorBinding` 애너테이션 : 생성자를 통한 의존성 주입을 지원
    - `@ConfigurationProperties` 애너테이션 : 설정 정보 파일의 프로퍼티와 매핑됨
    - 접두사: `app.sbip.ct`
    - 내부 정적 클래스: `Security`
        - `enabled` 프로퍼티: 보안 기능 활성화 여부

    ---

- @ConstructorBinding 애너테이션
    - 생성자를 통한 의존성 주입을 지원
    - `AppProperties` 클래스의 생성자는 `name`, `ip`, `port` 인자를 받음
- @ConfigurationProperties 애너테이션
    - 설정 정보 파일의 프로퍼티와 매핑
    - 접두사 : `app.sbip.ct`
    - `app.sbip.ct.name` 프로퍼티는 `name` 변수에 매핑
    - `app.sbip.ct.ip` 프로퍼티는 `ip` 변수에 매핑
    - `app.sbip.ct.port` 프로퍼티는 `port` 변수에 매핑
- 내부 정적 클래스 : Security
    - 보안 관련 프로퍼티를 담는 클래스
    - `enabled` 프로퍼티 : 보안 기능 활성화 여부

---

**AppService 클래스**

- 스프링 부트 애플리케이션의 비즈니스 로직을 담당하는 서비스 클래스
- 주요 특징
    - `@Service` 애너테이션 : 스프링 부트 빈으로 자동 등록됨
    - `AppProperties` 객체 주입 : 의존성 주입을 통해 `AppProperties` 객체를 받음
    - `AppProperties` 객체 활용: `AppProperties` 객체의 프로퍼티 값을 사용하여 비즈니스 로직을 수행

---

- @Service 애너테이션
    - 스프링 부트 빈으로 자동 등록됨
    - `AppService` 클래스는 스프링 부트 컨테이너가 자동으로 찾아서 빈으로 등록
- AppProperties 객체 주입
    - 의존성 주입을 통해 `AppProperties` 객체를 받음
    - `AppService` 클래스는 생성자를 통해 `AppProperties` 객체를 주입받음
- AppProperties 객체 활용
    - `AppProperties` 객체의 프로퍼티 값을 사용하여 비즈니스 로직을 수행
    - `AppService` 클래스는 `AppProperties` 객체의 `name`, `ip`, `port` 프로퍼티 값을 사용하여 비즈니스 로직을 수행 가능
- @EnableConfigurationProperties
    - 명시적으로 클래스 등록 필요
- @ConfigurationPropertiesScan
    - 기준 패키지 하위에 있는 @ConfigurationProperties 애너테이션이 붙어 있는 클래스를 자동 탐색

---

### 스프링 부트 애플리케이션 시작 시 코드 실행

**CommandLineRunner :** 스프링 부트 애플리케이션 시작 시 특정 코드를 실행하는 인터페이스

- 스프링 부트 애플리케이션 시작 시 특정 코드를 실행하려면 CommandLineRunner 인터페이스를 사용해야 함.
    - CommandLineRunner는 run() 메서드 하나만 가지고 있으며, 애플리케이션 초기화가 완료되기 직전에 실행
- `CommandLineRunner`를 사용하는 방법
    1. **스프링 부트 메인 클래스가 CommandLineRunner 인터페이스를 구현**

        ```java
        @SpringBootApplication
        public class CourseTrackerApplication implements CommandLineRunner {
            @Override
            public void run(String... args) throws Exception {
                // ...
            }
        }
        ```

    2. **@Bean을 사용하여 CommandLineRunner 빈 정의**

        ```java
        @SpringBootApplication
        public class CourseTrackerApplication implements {
            @Bean
            public CommandLineRunner commandLineRunner() {
                return args -> {
                    // ...
                };
            }
        }
        ```

    3. **@Component 애너테이션을 사용하여 CommandLineRunner 컴포넌트 정의**

        ```java
        @Order  // ~~ 밑에 설명 참고
        @Component
        public class MyCommandLineRunner implements CommandLineRunner {
            @Override
            public void run(String... args) throws Exception {
                // ...
            }
        }
        ```

        - 애플리케이션을 실행하면 스프링 부트 컴포넌트 탐색 기능을 통해 MyCommandLineRunner 컴포넌트 클래스의 인스턴스가 생성되고 빈으로 등록되며 로그가 콘솔에 표시.
        - CommandLineRunner 구현체는 여러 개를 등록할 수 있으며 @0rder 애너테이션으로 실행 순서를 정해줘야 함.
        - `@Order` 애너테이션으로 실행 순서 지정 가능

            ```java
            @Order(2)
            @Component
            public class AnotherCommandLineRunner implements CommandLineRunner {
              @Override
            	public void run (String... args) throws Exception {
            		// ...
            	｝
            }
            ```

        - 빈을 주입 받아 사용하는 CommandLineRunner 구현

            ```java
            @Bean
            public CommandLineRunner printCourses(CourseRepository courseRepository) {
                return args -> {
                    // ...
                    courseRepository.findAll().forEach(System.out::println);
                };
            }
            ```


    ---


### 스프링 부트 애플리케이션 로깅 커스터마이징

- 스프링 부트는 기본적으로 로그백 프레임워크 사용
- 다른 로깅 프레임워크 (ex. Log4j2) 사용 가능
- 로그 레벨, 어펜더, 필터 등 다양한 설정 가능

ex)

**1. 기본 로그 패턴 설정**

**Properties**

```jsx
logging.pattern.console=%clr%d{dd-MM-yyyy HH:mm:ss.SSS3) {yellow} %clr(${PID:- 3) {green}
%magenta ([%thread]) %highlight([%-5level]) %clr(%-40.401ogger{39}){cyan} %msg%n
```

**2. Log4j2 사용 설정**

- pom.xml에서 spring-boot-starter-logging 제거하고 spring-boot-starter-log4j2 추가
- log4j2.xml 설정 파일 생성

**3. Log4j2 설정**

**ex)**

```java
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
< Properties>
<Property name="LOG_PATTERN">
%d{yyyy-MM-dd HH: mm:ss. SSS} [%5p] [%15.15t] %-40.40c≤1.3 : %m%n%ex
</Property>
</Properties>
< Appenders>
< Console name="ConsoleAppender" target="SYSTEM_OUT">
<PatternLayout pattern="$ELOG_PATTERN？"/>
</Console>
‹RollingFile name="FileAppender"
fileName="logs/application-10g4j2.10g" filePattern="logs/application-10g4j2-%d{vYVY-MM-dd3-%i.10g">
⑤
< PatternLayout>
< Pattern>${LOG_PATTERN}</Pattern>
</PatternLayout>
‹ Policies>
«SizeBasedTriggeringPolicy size="10MB" />
<TimeBasedTriggeringPolicy interval="7 />
</Policies>
<DefaultRolloverStrategy max="18"/>
⑧
</RollingFile >
</ Appenders>
< Loggers>
⑨
<Logger name="com.manning.sbip" level="debug" additivity="false">
<AppenderRef ref="FileAppender"/>
</ Logger>
10
< Logger name="org.springframework.boot" level="info" additivity="false">
<AppenderRef ref="ConsoleAppender"/>
</ Logger>
<Root level="info">
12
<AppenderRef ref="FileAppender"/>
<AppenderRef ref="ConsoleAppender"/>
</Root>
</Loggers>
</Configuration>
```

**4. 로그 출력 코드**

```java
private static Logger logger = LoggerFactory.getLogger(CourseTrackerApplication.class);

public static void main(String[] args) {
    SpringApplication.run(CourseTrackerApplication.class, args);
    logger.info("CourseTrackerApplication started successfully with Log4j2 configuration");
}
```