**CHAPTER 3**

**람다 표현식**

lambda : 람다 미적분학 학계에서 개발한 시스템에서 유래

## 람다(lambda) 표현식

: 메서드로 전달할 수 있는 익명 함수를 단순화한 것

| 비교 항목 | 익명 클래스 | 람다 표현식 |
| --- | --- | --- |
| 코드 길이 | 길음 | 짧음 |
| 가독성 | 낮음 | 높음 |
| 유지 관리 | 어려움 | 쉬움 |
| 함수형 프로그래밍 | 지원하지 않음 | 지원함 |

이름은 없지만,

가질 수 있는 것 : 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트

### 특징

- 익명 : 보통의 메서드와 달리 이름이 없으므로 익명이라 표현, 구현해야 할 코드에 대한 걱정거리가 줄어듦
- 함수 : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라 부름, BUT 메서드처럼 파라미터 리스트, 바디, 반환형식, 가능한 예외 리스트를 포함
- 전달 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있음
- 간결성 : 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요 없음

```java
// 기존 코드
Comparator<Apple> byWeight = new Comparator<Apple>() {
	public int compare(Apple al, Apple a2) {
		return al.getWeight().compareTo(a2.getWeight());
	｝
｝；
```

```java
// 람다 이용한 코드
Comparator <Apple> byWeight =
	(Apple al, Apple a2) → al.getWeight().compareTo(a2.getWeight());
```

---

❗️ 람다 표현식은 세 부분으로 이루어짐

![스크린샷 2024-04-04 오전 1.37.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/bb292336-3059-4ccb-90c3-629c384e1d39/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.37.04.png)

- 파라미터 리스트 : Comparator 의 compare 메서드 파라미터(사과 두 개)
- 화살표 : 화살표(→)는 람다의 파라미터 리스트와 바디를 구분
- 람다 바디 : 두 사과의 무게를 비교, 람다의 반환값에 해당

---

### 자바 8에서 지원하는 5가지 람다 표현식 예제

```java
(String s) -> s.length()
```

```java
(Apple a) -> a.getWeight() > 150
```

```java
(int x, int y) -> {
	System.out.println("Result:");
	System.out.println(x + y);
}
```

```java
() -> 42
```

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

---

표현식 스타일 (expression style) 람다라고 알려진 람다의 기본 문법

`(parameters) → expression`

블록 스타일

`(parameters) → { statement; }`

---

람다 표현식 문법의 올바른 예시

- ( ) → { }
- ( ) → “Raoul”
- ( ) → { return “Mario”; }
- ( Integer i ) → { return “Alan” + i ; }
- ( String s ) → “Iron Man”
- ( String s) → { return “Iron Man”; }

---

![스크린샷 2024-04-04 오전 2.04.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/7c8df422-6444-41e5-bc75-bb60b1b11857/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.04.31.png)

---

## 함수형 인터페이스

: 추상 메서드 하나만 가지고 있는 인터페이스.

(람다는 함수형 인터페이스라는 문맥에서 사용할 수 있음.)

---

### 자바 API 의 함수형 인터페이스

```java
// java.util.Comparator
public interface <Comparator T>
	int compare(T o1, To2);
} 

// java.lang.Runnable
public interface Runnable {
	void run ();
}

// java.awt.event.ActionListener
public interface ActionListener extends EventListener { 
	void actionPerformed (ActionEvent e);
}

//java.util.concurrent.Callable
public interface Callable<V> {
	V call() throws Exception;
}

// java.security.PrivilegedAction
public interface PrivilegedAction<T> {
	T run ();
}
```

---

<aside>
💡 인터페이스는 **디폴트 메서드**(인터페이스의 메서드를 구현하지 않은 클래스를 고려해서 기본 구현을 제공하는 바디를 포함하는 메서드)를 포함할 수 있음. 많은 디폴트 메서드가 있더라도 **추상 메서드가 오직 하나**면 함수형 인터페이스.

</aside>

Q : 함수형 인터페이스로 가능한 것?

A : 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급(기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스)할 수 있음.    ——> 익명 내부 클래스로도 같은 기능 수행 가능.(덜 깔끔)

---

![Runnable 활용 예제](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/932880dd-16a8-4318-9478-f7f07172b2e1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.23.26.png)

Runnable 활용 예제

---

### 함수 디스크립터

: 함수형 인터페이스의 추상 메서드 시그니처(signatur)는 람다 표현식의 시그니처를 가리킴. 람다 표현식의 시그니처를 서술하는 메서드를 **함수 디스크립터**(function descriptor)라고 부른다.

(함수 디스크립터는 함수의 입력값과 출력값을 간결하게 표현하는 문법 요소. 람다 표현식을 사용할 때 함수의 시그니처를 명확하게 보여주고 코드의 가독성을 높여줌.)

ex) Runnable 인터페이스의 유일한 추상 메서드 run 은 인수와 반환값이 없으므로(void 반환) Runnable 인터페이스는 인수와 반환 값이 없는 시그니처.

- `(String) -> String`: 문자열을 입력으로 받아 문자열을 반환하는 함수
- `(Integer, Integer) -> Integer`: 두 개의 정수를 입력으로 받아 정수를 반환하는 함수
- `() -> void`: 입력값 없이 void를 반환하는 함수

---

람다 표현식 :

- 변수에 할당
- 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있음
- 함수형 인터페이스의 추상 메서드와 같은 시그니처를 가짐.

---

```java
public void process(Runnable r) {
	r. run();
｝

process(() → System.out.println("This is awesome!!"));
// 인수가 없으며 void 를 반환하는 람다 표현식
```

---

### @FunctionalInterface

: 함수형 인터페이스임을 가리키는 어노테이션

- @FunctionalInterface로 인터페이스를 선언했지만 함수형 인터페이스가 아니면 컴파일러가 에러 발생
- ex) 추상 메서드가 하나 이상이면 에러

---

## **람다의 활용 : 실행 어라운드 패턴**

: 자원을 열고, 처리하고, 닫는 작업을 람다 표현식을 사용하여 간결하게 표현하는 패턴

![중복되는 준비 코드와 정리 코드가 작업 A와 작업 B를 감싸고 있음.](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/ad553d74-fb07-4478-995f-3234e4624589/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.55.21.png)

중복되는 준비 코드와 정리 코드가 작업 A와 작업 B를 감싸고 있음.

### 함수형 인터페이스를 이용해서 람다를 전달하는 방법

- 파일의 한 행을 읽는 코드

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader(new FileReader ("data.txt"))) {
		return br. readLine();    // 실제 필요한 작업을 하는 행
	}
}
```

1. 동작 파라미터화를 기억하라

   → 위 코드는 파일에서 한 번에 한 줄만 읽을 수 있음. 한 번에 두 줄을 읽거나 가장 자주 사용되 는 단어를 반환하려면 어떻게 해야 할까? 기존의 설정, 정리 과정은 재사용하고 processFile 메서드만 다른 동작을 수행하도록 명령할 수 있다면 좋을 것. (processFile의 동작을 파라미터화)

   BufferedReader를 이용해 다른 동작을 수행할 수 있도록 람다를 이용해서 processFile 메서드로 동작을 전달. 우선 BufferedReader를 인수로 받아서 String을 반환하는 람다가 필요하다.

    ```java
    String result = processFile((BufferedReader br) -> br. readLine() + br.readLine());
    ```

2. 함수형 인터페이스를 이용해서 동작 전달

   → 함수형 인터페이스 자리에 람다를 사용할 수 있으니까 BufferedReader -> String과 IOException을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 함.

    ```java
    @FunctionalInterface
    public interface BufferedReaderProcessor {
    	String process(BufferedReader b) throws IOException;
    }
    ```

   정의한 인터페이스를 processFile 메서드의 인수로 전달 가능.

    ```java
    public String processFile(BufferedReaderProcessor p) throws IOException {
    	...
    }
    ```

3. 동작 실행

   → 이제 BufferedReaderProcessor에 정의된 process 메서드의 시그니처(BufferedReader -> String)와 일치하는 람다를 전달 가능해졌고 processFile 바디 내에서 BufferedReaderProcessor 객체의 process를 호출할 수 있음.

    ```java
    public String processFile(BufferedReaderProcessor p) throws IOException {
    	try (BufferedReader br = new BufferedReader (new FileReader ("data.txt"))) {
    		return p.process(br);    // BufferedReader 객체 처리
    	｝
    }
    ```

4. 람다 전달

   → 이제 람다를 이용해서 다양한 동작을 processFile 메서드로 전달할 수 있음.

    - 한 행을 처리하는 코드
      `String oneLine = processFile((BufferedReader br) - br.readLine());`
    - 두 행을 처리하는 코드
      `String twoLines = processFile((BufferedReader br) - br.readLine() + br.readLine());`

---

## 함수형 인터페이스 사용

: 다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요.
자바 8 라이브러리 설계자들은 java.util.function 패키지로 여러 가지 새로운 함수형 인터 페이스를 제공함.

### Predicate ( Java.util.function.Predicate <T>  )

- test라는 추상 메서드를 정의하며 test는 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환.
- 우리가 만들었던 인터페이스와 같은 형태인데 따로 정의할 필요 없이 바로 사용할 수 있음.
- T 형식의 객체를 사용하 는 불리언 표현식이 필요한 상황에서 Predicate 인터페이스를 사용할 수 있음. (다음 예제처럼 String 객체를 인수로 받는 람다를 정의할 수 있음.)

```java
@FunctionalInterface
public interface Predicate<T> {
	boolean test(T t);
｝
public <T> List<T> filter(List<T> list, Predicate<T> p) {
	List<T> results = new ArrayList<>();
	for(T t: list) {
		if(p.test(t)) {
			results.add(t);
		｝
	}
return results;
}
Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```

### Consumer ( Java.util.function.Consumer <T> )

- 제네릭 형식 T 객체를 받아서 void를 반환하 는 accept라는 추상 메서드를 정의함.
- T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용 가능. ex) Integer 리스트를 인수로 받아서 각 항목에 어떤 동작을 수행하는 forEach 메서드를 정의할 때

```java
@FunctionalInterface
public interface Consumer<T> {
	void accept(T t);
}
public <T> void forEach(List<T> list, Consumer<T> c) {
	for(T t: list) {
		c.accept(t);
	｝
}
forEach(
			Arrays.asList(1,2,3,4,5),
			(Integer i) -> System.out.println(i)  // Consumer의 accept 메서드를 구현하는 람다
);
```

### Function ( Java.util.function.Fuction <T, R> )

- 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의함.
- 입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 활용 가능(ex. 사과의 무게 정보를 추출하거나 문자열을 길이와 매핑).

```java
@FunctionalInterface
public interface Function<T, R> {
	R apply(T t);
｝
public <T, R> List<R> map(List<T> list, Function<T, R> f) 1
	List<R> result = new ArrayList<>();
	for(T t: list) {
		result.add(f.apply(t));
	}
	return result;
}
// [7,2,6]
List<Integer> 1 = map (
			Arrays.asList("lambdas", "in", "action"),
			(String s) -> s.length()    // Function의 apply 메서드를 수현하는 람다
);
```

### 기본형 특화

: 특화된 형식의 함수형 인터페이스
자바의 모든 형식은 참조형 아니면 기본형에 해당한다. 하지만 제네릭 파라미터 (ex. Consumer <T>의 T)에는 제네릭의 내부 구현 때문에 참조형만 사용할 수 있다.

- 박싱(boxing) : 기본형을 참조형으로 변환하는 기능
- 언박싱(unboxing) : 참조형을 기본형으로 변환하는 반대 동작
- 오토박싱(autoboxing) : 프로그래머가 편리하게 코드를 구현할 수 있도록 박싱과 언박싱이 자동으로 이루어지는 기능

ex) 나쁜 예?

```java
List<Integer> list = new ArrayList<>();
for (int i = 300; i < 400; i++) {
	list.add(i);
}
```

(자바 8에서는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있도록 특별 한 버전의 함수형 인터페이스를 제공)

```java
public interface IntPredicate {
	boolean test(int t);
}
Intpredicate evenNumbers = (int i) -> i % 2 == 0;
evenNumbers.test(1000); // 참(박싱 없음)

Predicate<Integer> oddNumbers = (Integer i) -> i % 2 != 0;
oddNumbers.test(1000): // 거짓(박싱)
```

![스크린샷 2024-04-04 오전 4.04.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/71631b3a-0584-455b-9257-ec54e80d6179/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.04.17.png)

함수형 인터페이스와 람다의 요약

![그림1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/a517b610-5832-42f0-86d6-d5dc8d1b1f1a/%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B71.png)

예외, 람다, 함수형 인터페이스의 관계

- 함수형 인터페이스 : 확인된 예외를 던질 수 없음.
- 람다 : 예외를 던질 수 있음

  Q : 예외를 던지는 람다 표현식을 만들려면?

    1. 람다를 try / catch 블록으로 감싸기
    2. 확인된 예외를 선언하는 함수형 인터페이스를 직접 정의

---

## 형식 검사, 형식 추론, 제약

람다로 함수형 인터페이스의 인스턴스를 만들 수 있음.

→ 람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않으므로 제대로 이해하려면 람다의 실제 형식 파악 필요.

### 형식 검사

람다가 사용되는 콘텍스트(context)를 이용해서 람다의 형식(type)을 추론할 수 있음.

콘텍스트 예시) 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등

- **대상 형식(target typing)** : 어떤 콘텍스트에서 기대되는 람다 표현식의 형식

```java
List<Apple> heavierThan150g =
filter(inventory, (Apple apple) -> apple.getWeight() › 150);
```

1. filter 메서드의 선언을 확인한다.
2. filter 메서드는 두 번째 파라미터로 Predicate Apple> 형식 (대상 형식)을 기대한다.
3. Predicate 〈Apple〉은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

![람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws 로 선언해야 함.](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/5b742f86-432b-45f5-aa9e-ef1d0b8c121b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.30.24.png)

람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws 로 선언해야 함.

---

### 같은 람다, 다른 함수형 인터페이스

- 대상 형식이라는 특징 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있음.
    - ex) 이전에 살펴본 Callable과 PrivilegedAction 인터페이스는 인수를 받지 않고 제네릭 형식 T를 반환하는 함수를 정의.

    ```java
    Callable<Integer> C = () -> 42;
    PrivilegedAction<Integer> p = () -> 42;
    ```

  첫 번째 할당문의 대상 형식 : Callable<Integer>

  두 번째 할당문의 대상 형식 : PrivilegedAction<Integer>

    ```java
    Comparator<Apple> c1 = 
    			(Apple al, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
    
    ToIntBiFunction<Apple, Apple> c2 = 
    			(Apple al, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
    
    BiFunction<Apple, Apple, Integer> c3 = 
    			(Apple al, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
    ```
    
  ---

  **다이아몬드 연산자**( **<>** ) : 콘텍스트에 따른 제네릭 형식을 추론 가능.

    - 주어진 클래스 인스턴스 표현식을 두 개 이상의 다양한 콘텍스트에 사용 가능.
    - 이때 인스턴스 표현식의 형식 인수는 콘텍스트에 의해 추론됨.

  `List<String> listOfStrings = new ArrayList<>();
  List<Integer> listOfIntegers = new ArrayList<>();`

  **특별한 void 호환 규칙**

    - 람다의 바디에 일반 표현식이 있으면 void를 반환하는 함수 디스크립터와 호환됨(물론 파라미터 리스트도 호환되어야 함).

    ```java
    // Predicate는 불리언 반환값을 갖는다.
    Predicate<String> p = s -> list.add(s);
    // Consumer는 void 반환값을 갖는다.
    Consumer<string> b = s -> list.add(s);
    ```

  할당문 콘텍스트, 메서드 호출 콘텍스트(파라미터, 반환값), 형변환(cast) 콘텍스트 등으로 람다 표현식의 형식을 추론할 수 있음.

    - 예시

        ```java
        // 에러 (Object 는 함수형 인터페이스가 아님)
        Object o = () -> { System.out.println("Tricky example"); };
        
        // ---------------고치기------------------
        // () -> void 형식의 함수 디스크립터를 갖는 Runnable로 대상 형식을 바꿔줌
        Runnable r = () -> { System.out.printin("Tricky example"); };
        
        // 람다 표현식을 명시적으로 대상 형식을 제공하는 Runnable로 캐스팅
        Object o = (Runnable) () -> { System.out.println("Tricky example"); };
        ```

        - 같은 함수형 디스크립터를 가진 두 함수형 인터페이스를 갖는 메소드를 오버로딩할 때 활용 가능.
        - 어떤 메소드의 시그니처가 사용되어야 하는지를 명시적으로 구분하도록 람다를 캐스트할 수 있음.

        ```java
        execute(() -> {})    
        // 이런 람다 표현식이 있다면 Runnable과 Action의 함수 디스크립터가 같으므로 
        // 누구를 가리키는지가 명확하지 않음.
        
        public void execute(Runnable runnable) {
        	runnable.run();
        ｝
        public void execute(Action<T> action) {
        	action.act();
        }
        @FunctionalInterface
        interface Action {
        	void act();
        ｝
        
        // 다음처럼 캐스트를 하면 누구를 호출할 것인지가 명확해짐.
        execute((Action) () -> {});
        ```


### 형식 추론

자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론함.

—> 대상 형식을 이용해서 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있음.

—> 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 람다 문법에서 이를 생략할 수 있음.

```java
List<Apple> greenApples =
		filter(inventory, apple -> GREEN.equals(apple.getColor()));
// 파라미터 a에는 형식을 명시적으로 지정하지 않았음.
```

```java
// 형식을 추론 하지 않음
Comparator<Apple> c =    
		(Apple al, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
// 형식을 추론함
Comparator<Apple> c =
		(a1, a2) -> al.getWeight().compareTo(a2.getWeight());
```

---

### 지역 변수 사용

**람다 캡처링**(capturing lambda) : 람다 표현식이 외부 범위에서 선언된 변수를 참조할 수 있도록 하는 기능

- 람다 표현식에서는 익명 함수가 하는 것처럼 자유 변수를 활용할 수 있음.
    - 자유 변수(free variable) : 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수
- 람다 표현식은 익명 함수와 유사하지만, 외부 범위의 변수를 직접 사용할 수 있다는 장점이 있음

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

- 자유 변수의 제약 :
    - 람다 표현식은 컴파일 시점에 이미 결정된 값을 참조하기 때문에, 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있음.
        - 캡처 : 자신의 바디에서 참조함
        - 만약 지역 변수가 여러 번 할당될 수 있다면, 람다 표현식이 실행되는 시점에 지역 변수의 값이 불확실해지므로 캡처링할 수 없음.

        ```java
        // 에러
        // 람다에서 참고하는 지역 변수는 final로 선언되거나 실질적으로 final 처럼 취급되어야 함.
        int portNumber = 1337;
        Runnable r = () -> System.out.println(portNumber);
        portNumber = 31337;
        ```

- 지역 변수의 제약 :
    - 인스턴스 변수 : 힙 메모리에 저장
    - 지역 변수 : 스택에 저장

    <aside>
    💡 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 이유 :

  Q : 람다에서 지역 변수에 바로 접근할 수 있다면 ?

  람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있음.

  자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공.

  따라서 복사본의 값이 바뀌지 않아야 하므로 !

    </aside>

- 클로저 (closure)

  : 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스.

  ex) 클로저를 다른 함수의 인수로 전달할 수 있음.

    - 클로저는 클로저 외부에 정의된 변수의 값에 접근하고, 값을 바꿀 수 있음.
    - 자바 8의 람다와 익명 클래스는 클로저와 비슷한 동작을 수행함.
    - 람다와 익명 클래스 모두 메서드의 인수로 전달될 수 있으며 자신의 외부 영역의 변수에 접근할 수 있음.
    - 람다와 익명 클래스는 람다가 정의된 메서드의 지역 변수의 값은 바꿀 수 없음.
    - 람다가 정의된 메서드 의 지역 숫값은 final 변수여야 함. 덕분에 람다는 변수가 아닌 값에 국한되어 어떤 동작을 수행한다는 사실이 명확해짐.
    - 지역 변숫값은 스택에 존재하므로 자신을 정의한 스레드와 생존을 같이 해야 하며 따라서 지역 변수는 final이어야 함.
    - 가변 지역 변수를 새로운 스레드에서 캡처할 수 있다면 안전하지 않은 동작을 수행할 가능성이 생김.(인스턴스 변수는 스레드가 공유하는 힙에 존재하므로 특별한 제약이 없다)

---

## 메서드 참조 ( :: )

특정 메서드만을 호출하는 람다의 축약형

활용법 : 메서드명 앞에 구분자(::)를 붙이는 방식

- 메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있음
- 때로는 람다 표현식보다 메서드 참조를 사용하는 것이 더 가독성이 좋으며 자연스러움.
- 컴파일러는 람다 표현식의 형식을 검사하던 방식과 비슷한 과정으로 메서드 참조가 주어진 함수형 인터페이스와 호환하는지 확인하므로, 메서드 참조는 콘텍스트의 형식과 일치해야 함.

```java
inventory.sort((Apple al, Apple a2) ->
		al.getWeight().compareTo(a2.getWeight()));
```

```java
inventory.sort(comparing(Apple::getWeight));
// 람다 표현식 (Apple a) -> a.getWeight()를 축약한 것
```

![스크린샷 2024-04-04 오후 10.54.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/3e9ccd3e-ef65-4d2e-ad0b-74fef3d63ce3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.54.46.png)

---

### 메서드 참조의 3가지 유형

1. 정적 메서드 참조
   ex) Integer의 parseInt 메서드는 `Integer::parseInt` 로 표현
2. 다양한 형식의 인스턴스 메서드 참조
   ex) String의 length 메서드는 `String::length`로 표현

    ```java
    (String s) -> s.toUpperCase()    // 람다 표현식
    String::toUpperCase              // 메서드 참조
    ```

3. 기존 객체의 인스턴스 메서드 참조
   ex) Transaction 객체를 할당받은 expensiveTransaction 지역 변수가 있고, Transaction 객체에는 getValue 메서드가 있다면, `expensiveTransaction::getValue` 라고 표현

    ```java
    () -> expensiveTransaction.getValue()    // 람다 표현식
    expensiveTransaction::getValue           // 메서드 참조
    ```

    ```java
    private boolean isValidName(String string) {
    	return Character.isUpperCase(string.charAt(0));
    }
    
    // Predicate<String> 를 필요로 하는 적당한 상황에서 메서드 참조 사용
    filter(words, this::isValidName)
    ```


![스크린샷 2024-04-04 오후 11.05.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/0ab6a958-7ae7-4821-b1c9-1e10a33d7066/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.05.43.png)

```java
List<String> str = Arrays.asList"a", "b", "A", "B");
str.sort((s1, s2) -> s1.compareToIgnoreCase(s2));
```

```java
List<String> str = Arrays.asList("a", "b", "A", "B");
str.sort(String::compareToIgnoreCase);
```

---

### 생성자 참조

기존 생성자의 참조 생성 : ClassName::new 처럼 클래스명과 new 키워드를 이용

- 정적 메서드의 참조를 만드는 방법과 비슷함

  ex) Supplier의 () -> Apple 과 같은 시그니처를 갖는 생성자

    ```java
    Supplier<Apple> c1 = Apple::new;
    Apple a1 = C1.get();
    // Supplier의 get 메서드를 호출해서 새로운 Apple 객체를 만들 수 있음.
    
    //------------위 아래 같은 코드--------------------
    Supplier<Apple> c1 = () -> new Apple(); 
    // 람다 표현식은 디폴트 생성자를 가진 Apple을 만듦.
    Apple a1 = c1.get();
    // Supplier의 get 메서드를 호출해서 새로운 Apple 객체를 만들 수 있음.
    ```

    ```java
    Function<Integer, Apple〉 c2 = Apple::new; 
    // Apple(Integer weight)의 생성자 참조
    Apple a2 = c2.apply(110);
    // Function의 apply 메서드에 무게를 인수로 호출해서 새로운 Apple 객체를 만들 수 있음.
    
    //------------위 아래 같은 코드--------------------
    Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
    // 특정 무게의 사과를 만드는 람다 표현식
    Apple a2 = c2.apply(110);
    // Function의 apply 메서드에 무게를 인수로 호출해서 새로운 Apple 객체를 만들 수 있음.
    ```

    ```java
    List<Integer> weights = Arrays.asList(7, 3, 4, 10);
    List<Apple> apples = map(weights, Apple::new); // map 메서드로 생성자 참조 전달
    public List<Apple> map(List<Integer> list, Function<Integer, Apple> f) {
    	List<Apple> result = new ArrayList<>();
    	for(Integer i: list) {
    		result.add(f.apply(i));
    	｝
    	return result;
    ｝
    ```

    ```java
    BiFunction<Color, Integer, Apple> c3 = Apple::new;
    // Apple(String color, Integer weight)의 생성자 참조
    Apple a3 = c3.apply(GREEN, 110);
    // BiFunction의 apply 메서드에 색과 무게를 인수로 제공해서 새로운 Apple 객체를 만들 수 있음.
    
    //------------위 아래 같은 코드--------------------
    BiFunction<String, Integer, Apple> c3 =
    		(color, weight) -> new Apple(color, weight);
    // 특정 색과 무게를 가진 사과를 만드는 람다 표현식
    Apple a3 = c3.apply(GREEN, 110); 
    // BiFunction의 apply 메서드에 색과 무게를 인수로 제공해서 새로운 Apple 객체를 만들 수 있음.
    ```

- 인스턴스화하지 않고도 생성자에 접근할 수 있는 기능을 다양한 상황에 응용할 수 있음.

    ```java
    static Map<String, Function<Integer, Fruit>> map = new HashMap<>();
    static {
    	map.put("apple", Apple::new); 
    	map.put("orange", Orange::new);
    	// 등등
    }
    ```

    ```java
    public static Fruit giveMeFruit(String fruit, Integer weight){
    	return map.get(fruit.toLowerCase()) // map에서 Function(Integer, Fruit〉를 얻음.
    			.apply(weight);  // Function의 apply 메서드에 정수 무게 파라미터를 제공해서 Fruit를 만들 수 있음.
    ```

- Color(int, int, int)처럼 인수가 세 개인 생성자의 생성자 참조를 사용하려면 어떻게 해야 할까?

  Answer : 생성자 참조 문법은 ClassName::new이므로 Color 생성자의 참조는 Color::new가 된다. 하지만 이를 사용하려면 생성자 참조와 일치하는 시그니처를 갖는 함수형 인터페이스가 필요하다. 현재 이런 시그니처를 갖는 함수형 인터페이스는 제공되지 않으므로 우리가 직접 다음과 같은 함수형 인터페이스를 만들어야 한다.

    ```java
    public interface TriFunction<T, U, V, R> {
    	R apply(T t, U u, V v);
    }
    ```

  이제 이렇게 새로운 생성자 참조를 사용할 수 있다.

  `TriFunction<Integer, Integer, Integer, Color> colorFactory = Color::new;`


---

## 람다, 메서드 참조 활용하기

### 1단계 : 코드 전달

어떻게 sort 메서드에 정렬 전략을 전달할 수 있을까?

sort 메서드의 시그니처 : `void sort(Comparator<? super E> c)`

- Comparator 객체를 인수로 받아 두 사과를 비교
- 객체 안에 동작을 포함시키는 방식으로 다양한 전략을 전달 가능
- 'Sort의 동작은 파라미터화되었다'라고 말할 수 있음
- sort에 전달된 정렬 전략에 따라 Sort의 동작이 달라질 것

```java
public class AppleComparator implements Comparator<Apple> {
	public int compare(Apple a1, Apple a2){
		return al.getWeight().compareTo(a2.getWeight());
	}
}
inventory.sort(new AppleComparator());
```

### 2단계 : 익명 클래스 사용

한 번만 사용할 Comparator를 위 코드처럼 구현하는 것보다는 **익명 클래스**를 이용하는 것이 좋음.

```java
inventory.sort(new Comparator<Apple>() {
	public int compare(Apple a1, Apple a2){
		return al.getWeight().compareTo(a2.getWeight());
	}
});
```

### 3단계 : 람다 표현식 사용

- 자바 8에서는 람다 표현식이라는 경량화된 문법을 이용 해서 코드를 전달 가능
- 함수형 인터페이스를 기대하는 곳 어디에서나 람다 표현식을 사용할 수 있음
- 함수형 인터페이스란 오직 하나의 추상 메서드를 정의하는 인터페이스
- 추상 메서드의 시그니처(함수 디스크립터라 불림)는 람다 표현식의 시그니처를 정의함

Comparator의 함수 디스크립터는 (T, T) → int

우리는 사과를 사용할 것이므로 더 정확히는 (Apple, Apple) -> int 로 표현

```java
inventory.sort((Apple a1, Apple a2) ->
				al.getWeight().compareTo(a2.getWeight())
);    // 개선된 코드

inventory.sort((a1, a2) -> 
				a1.getWeight().compareTo(a2.getWeight()));
// 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해서 람다의 파라미터 형식을 추론하므로 코드를 더 줄일 수 있음

Comparator<Apple> c = 
				Comparator.comparing((Apple a) -> a.getWeight());
// Comparing 메서드를 사용해서 가독성 더 향상

import static java.util.Comparator.comparing;
inventory.sort(comparing(apple -> apple.getWeight()));
// 최종 간소화
```

### 4단계 : 메서드 참조 사용

- 메서드 참조를 이용하면 람다 표현식의 인수를 더 깔끔하게 전달
- 메서드 참조를 이용해서 코드를 조금 더 간소화 가능

최적의 코드 !

```java
// java.util.Comparator.comparing 은 정적으로 임포트했다고 가정
inventory.sort(comparing(Apple::getWeight));
```

---

## 람다 표현식을 조합할 수 있는 유용한 메서드

자바 8 API의 몇몇 함수형 인터페이스는 다양한 유틸리티 메서드를 포함

ex) Comparator, Function, Predicate 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있도록 유틸리티 메서드를 제공

—> 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 것

ex)

- 두 프레디케이트를 조합해서 두 프레디케이트의 or 연산을 수행하는 커다란 프레디케이트를 만들기
- 한 함수의 결과가 다른 함수의 입력이 되도록 두 함수를 조합하기

도대체 함수형 인터 페이스에서는 어떤 메서드를 제공하기에 이런 일이 가능한지 ???

함수형 인터페이스에서 추가로 메서드를 제공한다는 것 자체가 함수형 인터페이스의 정의에 어긋나지 않는가!

—> 디폴트 메서드(default method) : 추상 메서드가 아니므로 함수 형 인터페이스의 정의를 벗어나지 않음

---

## Comparator 조합

정적 메서드 Comparator.comparing을 이용해서 비교에 사용할 키를 추출 하는 Function 기반의 Comparator를 반환할 수 있음.

`Comparator<Apple> c = Comparator.comparing(Apple::getWeight);`

### 역정렬

사과의 무게를 내림차순으로 정렬하고 싶다면 ?

—> 인터페이스 자체에서 주어진 비교자의 순서를 뒤바꾸는 reverse 디폴트 메서드 제공

```java
inventory.sort(comparing(Apple::getWeight).reversed());
// 무게를 내림차순으로 정렬
```

### Comperator 연결

무게가 같은 두 사과가 존재한다면 ? 정렬된 리스트에서 어떤 사과를 먼저 나열해야 할까 ?

—> 비교 결과를 더 다듬을 수 있는 두 번째 Comparator를 만들 수 있음

ex) 무게로 두 사과를 비교한 다음에 무게가 같다면 원산지 국가별로 사과를 정렬

thenComparing 메서드로 두 번째 비교자를 만들 수 있음

- thencomparing은 (comparing 메서드처럼) 함수를 인수로 받아 첫 번째 비교자를 이용해 서 두 객체가 같다고 판단되면 두 번째 비교자에 객체를 전달함

```java
inventory.sort(comparing(Apple::getWeight)
				.reversed()   // 무게를 내림차순으로 정렬
				.thenComparing(Apple::getCountry));   // 두 사과의 무게가 같으면 국가별로 정렬
```

### Predicate 조합

Predicate 인터페이스는 복잡한 프레디케이트를 만들 수 있도록 negate, and, or 세 가지 메서드를 제공함

ex)

- '빨간색이 아닌 사과'처럼 특정 프레디케이트를 반전시킬 때 negate 메서드를 사용
- and 메서드를 이용해서 빨간색이면서 무거운 사과를 선택하도록 두 람다를 조합
- or을 이용해서 '빨간색이면서 무거운 (150그램 이상) 사과 또는 그냥 녹색 사과'

```java
Predicate<Apple> notRedApple = redApple.negate();
// 기존 프레디케이트 객체 redApple의 결과를 반전시킨 객체를 만든다.

Predicate<Apple> redAndHeavyApple =
redApple.and(apple -> apple.getWeight() > 150);
// 두 프레디케이트를 연결해서 새로운 프레디케이트 객체를 만든다.

Predicate<Apple> redAndHeavyAppleOrGreen =
			redApple.and(apple -> apple.getWeight() > 150)
					.or(apple -> GREEN.equals(a.getColor()));
// 프레디케이트 메서드를 연결해서 더 복잡한 프레디케이트 객체를 만든다.
```

단순한 람다 표현식을 조합해서 더 복잡한 람다 표현식을 만들기!

심지어 람다 표현식을 조합해도 코드 자체가 문제를 잘 설명한다는 점~

### Function 조합

Function 인터페이스에서 제공하는 람다 표현식도 조합할 수 있음

Function 인터페이스 : Function 인스턴스를 반환하는 andThen, compose 두 가지 디폴트 메서드를 제공

- andThen 메서드 : 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환

  ex)

  숫자를 증가(x → x + 1)시키는 f 라는 함수가 있고, 숫자에 2를 곱하는 g라는 함수가 있다고 가정하자. 이제 다음처럼 f와 g를 조립해서 숫자를 증가시킨 뒤 결과에 2를 곱하는 h라는 함수를 만들 수 있다.

    ```java
    Function<Integer, Integer> f = x -> x + 1;
    Function<Integer, Integer> g = x -> × * 2;
    Function<Integer, Integer> h = f.andThen(g); // 수학으로는 write g(f(x)) 또는 (g o f)(x)라고 표현
    int result = h.apply(1);    // 4를 반환
    ```


- compose 메서드 : 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부 함수의 인수로 제공. 즉, f.andThen (g)에서 andThen 대신에 compose를 사용하면 g(f(x))가 아니라 f (g(x)) 라는 수식이 됨.

    ```java
    Function<Integer, Integer> f = x -> x + 1;
    Function<Integer, Integer> g = x -> x * 2;
    Function<Integer, Integer> h = f.compose(g): // 수학으로는 f(g(x)) 또는 (f o g)(x)라고 표현 
    int result = h.apply(1);   // 3을 반환
    ```
    
  ---

    - ex) 문자열로 구성된 편지 내용을 변환하는 다양한 유틸리티 메서드가 있다고 가정

        ```java
        public class Letter {
        	public static String addHeader (String text) {
        		return "From Raoul, Mario and Alan: " + text;
        	}
        	public static String addFooter(String text) {
        		return text + " Kind regards";
        	｝
        	public static String checkSpelling(String text) {
        		return text.replaceAll( "labda", "lambda");
        	}
        }
        ```

      ![유틸리티 메서드를 조합해서 다양한 변환 파이프라인을 만들 수 있음](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/ca3879ff-b1b4-40a4-89dd-487df7cfb757/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-05_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.12.45.png)

      유틸리티 메서드를 조합해서 다양한 변환 파이프라인을 만들 수 있음

      ![스크린샷 2024-04-05 오전 3.14.45.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/81126acb-9242-416a-970d-78a4341edac1/f53689a6-3845-457d-9e46-e03957f14585/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-05_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.14.45.png)

        ```java
        Function<String, String> addHeader = Letter::addHeader;
        Function<String, String> transformationPipeline = 
        		addHeader.andThen(Letter::checkSpelling)
        						 .andThen (Letter:: addFooter);
        ```

        ```java
        Function<String, String> addHeader = Letter::addHeader;
        Function<String, String> transformationPipeline = 
        		addHeader.andThen(Letter::addFooter);
        ```